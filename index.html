<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>QR Code Generator</title>

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #0b0f17;
      color: #fff;
      min-height: 100vh;
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      box-sizing: border-box;
    }

    .card {
      background: #121826;
      padding: 24px;
      border-radius: 12px;
      width: 100%;
      max-width: 520px;
      box-shadow: 0 10px 30px rgba(0,0,0,.4);
      box-sizing: border-box;
    }

    h1 {
      margin: 0 0 14px 0;
      font-size: 22px;
      line-height: 1.2;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 14px;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 14px;
    }

    label {
      font-size: 12px;
      font-weight: 500;
      color: rgba(255,255,255,.75);
      margin: 0;
    }

    input, select {
      width: 100%;
      height: 44px;
      padding: 10px 12px;
      border-radius: 8px;
      border: none;
      font-size: 15px;
      background: #fff;
      color: #000;
      box-sizing: border-box;
    }

    input[type="range"] { padding: 0; }
    input[type="file"] { padding: 9px 12px; }

    .row3 {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
      margin-top: 14px;
    }

    .hint {
      font-size: 12px;
      color: rgba(255,255,255,.70);
      line-height: 1.45;
      margin-top: 12px;
      padding: 10px 12px;
      border-radius: 10px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.08);
    }

    .hint strong { color: rgba(255,255,255,.92); }
    .hint.warn {
      background: rgba(245, 158, 11, .12);
      border: 1px solid rgba(245, 158, 11, .35);
    }
    .hint.bad {
      background: rgba(239, 68, 68, .12);
      border: 1px solid rgba(239, 68, 68, .35);
    }

    .small {
      font-size: 12px;
      color: rgba(255,255,255,.65);
    }

    .actions {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 18px;
    }

    button {
      width: 100%;
      height: 44px;
      padding: 0 12px;
      border-radius: 8px;
      border: none;
      font-size: 15px;
      cursor: pointer;
      box-sizing: border-box;
    }

    button.primary {
      background: #6366f1;
      color: #fff;
    }

    button.secondary {
      background: #1f2937;
      color: #fff;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    #qr {
      margin-top: 18px;
      display: flex;
      justify-content: center;
    }

    #qr canvas {
      max-width: 100%;
      height: auto;
      display: block;
    }

    .inline-note {
      margin-top: 6px;
      font-size: 12px;
      color: rgba(255,255,255,.65);
    }

    .toggle {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 8px;
      user-select: none;
    }
    .toggle input[type="checkbox"] {
      width: 18px;
      height: 18px;
      margin: 0;
      accent-color: #6366f1;
    }

    .preview {
      margin-top: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .preview img {
      width: 48px;
      height: 48px;
      object-fit: cover;
      border-radius: 10px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>QR Code Generator</h1>

    <div class="field">
      <input id="text" placeholder="Enter a URL or text" />
      <div class="small">Tip: If you type a bare domain like <code>example.com</code>, we’ll assume <code>https://</code>.</div>
    </div>

    <!-- Print + robustness controls -->
    <div class="grid">
      <div class="field" style="margin-top:0;">
        <label for="printSize">Print width</label>
        <input id="printSize" type="number" min="0.5" step="0.1" value="2.0" />
      </div>

      <div class="field" style="margin-top:0;">
        <label for="printUnit">Units</label>
        <select id="printUnit">
          <option value="in" selected>inches</option>
          <option value="cm">cm</option>
        </select>
      </div>

      <div class="field" style="margin-top:0;">
        <label for="dpi">DPI (export)</label>
        <select id="dpi">
          <option value="150">150</option>
          <option value="300" selected>300 (recommended)</option>
          <option value="600">600</option>
        </select>
      </div>

      <div class="field" style="margin-top:0;">
        <label for="ecLevel">Error correction</label>
        <select id="ecLevel">
          <option value="auto" selected>Auto (recommended)</option>
          <option value="M">M (balanced)</option>
          <option value="Q">Q (more robust)</option>
          <option value="H">H (most robust)</option>
        </select>
      </div>
    </div>

    <!-- Style controls -->
    <div class="grid">
      <div class="field" style="margin-top:0;">
        <label for="frameCorners">Frame corners</label>
        <select id="frameCorners">
          <option value="square" selected>90° (square)</option>
          <option value="rounded">Rounded</option>
        </select>
      </div>

      <div class="field" style="margin-top:0;">
        <label for="cornerRadius">Corner radius</label>
        <input id="cornerRadius" type="range" min="0" max="48" step="1" value="12" />
        <div class="inline-note" id="cornerRadiusNote">12 px</div>
      </div>

      <div class="field" style="margin-top:0;">
        <label for="quietZone">Quiet zone</label>
        <select id="quietZone">
          <option value="4" selected>4 modules (standard)</option>
          <option value="6">6 modules (extra safe)</option>
          <option value="8">8 modules (very safe)</option>
        </select>
      </div>

      <div class="field" style="margin-top:0;">
        <label for="fileType">Download format</label>
        <select id="fileType">
          <option value="png" selected>PNG (recommended)</option>
          <option value="jpeg">JPEG</option>
          <option value="webp">WEBP</option>
        </select>
      </div>
    </div>

    <!-- Color controls -->
    <div class="grid">
      <div class="field" style="margin-top:0;">
        <label for="fgColor">QR color (foreground)</label>
        <input id="fgColor" type="color" value="#000000" />
      </div>

      <div class="field" style="margin-top:0;">
        <label for="bgColor">Background/frame color</label>
        <input id="bgColor" type="color" value="#ffffff" />
      </div>
    </div>

    <!-- Logo controls -->
    <div class="field">
      <label>Logo</label>
      <div class="toggle">
        <input id="logoEnabled" type="checkbox" />
        <span>Enable logo (center)</span>
      </div>
      <input id="logoFile" type="file" accept="image/*" />
      <div class="preview" id="logoPreviewRow" style="display:none;">
        <img id="logoPreview" alt="Logo preview" />
        <div class="small" id="logoInfo"></div>
      </div>

      <div class="row3">
        <div class="field" style="margin-top:0;">
          <label for="logoSize">Logo size</label>
          <input id="logoSize" type="range" min="10" max="25" step="1" value="16" />
          <div class="inline-note" id="logoSizeNote">16%</div>
        </div>

        <div class="field" style="margin-top:0;">
          <label for="logoPadding">Logo padding</label>
          <input id="logoPadding" type="range" min="0" max="20" step="1" value="8" />
          <div class="inline-note" id="logoPaddingNote">8 px</div>
        </div>

        <div class="field" style="margin-top:0;">
          <label for="logoPlate">Plate color</label>
          <input id="logoPlate" type="color" value="#ffffff" />
        </div>
      </div>

      <div class="small">Tip: Logos reduce scannability. We’ll automatically bump error correction when logo is enabled.</div>
    </div>

    <div class="hint" id="printHint"></div>

    <div class="actions">
      <button class="primary" id="generate">Generate</button>
      <button class="secondary" id="download" disabled>Download</button>
    </div>

    <div id="qr"></div>
  </div>

  <!-- QR matrix generator (custom rendering) -->
  <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.js"></script>

  <script>
    // --- DOM refs
    const input = document.getElementById("text");
    const printSizeEl = document.getElementById("printSize");
    const printUnitEl = document.getElementById("printUnit");
    const dpiEl = document.getElementById("dpi");
    const ecSelect = document.getElementById("ecLevel");

    const frameCornersEl = document.getElementById("frameCorners");
    const cornerRadiusEl = document.getElementById("cornerRadius");
    const cornerRadiusNote = document.getElementById("cornerRadiusNote");

    const quietZoneEl = document.getElementById("quietZone");
    const fileTypeEl = document.getElementById("fileType");

    const fgColorEl = document.getElementById("fgColor");
    const bgColorEl = document.getElementById("bgColor");

    const logoEnabledEl = document.getElementById("logoEnabled");
    const logoFileEl = document.getElementById("logoFile");
    const logoPreviewRow = document.getElementById("logoPreviewRow");
    const logoPreviewImg = document.getElementById("logoPreview");
    const logoInfoEl = document.getElementById("logoInfo");
    const logoSizeEl = document.getElementById("logoSize");
    const logoSizeNote = document.getElementById("logoSizeNote");
    const logoPaddingEl = document.getElementById("logoPadding");
    const logoPaddingNote = document.getElementById("logoPaddingNote");
    const logoPlateEl = document.getElementById("logoPlate");

    const hintEl = document.getElementById("printHint");
    const genBtn = document.getElementById("generate");
    const dlBtn = document.getElementById("download");
    const qrBox = document.getElementById("qr");

    // --- Helpers
    function looksLikeBareDomain(s) {
      return (
        /^[^\s]+$/.test(s) &&
        s.includes(".") &&
        !/^[a-zA-Z][a-zA-Z0-9+.-]*:\/\//.test(s)
      );
    }

    function normalizeValue(raw) {
      let v = String(raw ?? "").trim();
      if (looksLikeBareDomain(v)) v = "https://" + v;
      v = v.replace(/\r\n/g, "\n");
      return v;
    }

    function inchesFrom(size, unit) {
      const n = Number(size);
      if (!Number.isFinite(n) || n <= 0) return null;
      return unit === "cm" ? (n / 2.54) : n;
    }

    function mmFromInches(inches) {
      return inches * 25.4;
    }

    // EC strength ordering for upgrades
    const EC_ORDER = ["M", "Q", "H"];
    function maxEC(a, b) {
      return EC_ORDER.indexOf(a) >= EC_ORDER.indexOf(b) ? a : b;
    }

    function exportPxFromPrint(inches, dpi) {
      const px = Math.round(inches * dpi);
      return Math.max(256, Math.min(px, 4096));
    }

    // --- Contrast utilities (WCAG contrast ratio)
    function hexToRgb(hex) {
      const h = String(hex || "").replace("#", "").trim();
      if (h.length !== 6) return null;
      const r = parseInt(h.slice(0, 2), 16);
      const g = parseInt(h.slice(2, 4), 16);
      const b = parseInt(h.slice(4, 6), 16);
      if ([r,g,b].some(v => Number.isNaN(v))) return null;
      return { r, g, b };
    }

    function srgbToLinear(c) {
      const cs = c / 255;
      return cs <= 0.04045 ? cs / 12.92 : Math.pow((cs + 0.055) / 1.055, 2.4);
    }

    function relativeLuminance(rgb) {
      const R = srgbToLinear(rgb.r);
      const G = srgbToLinear(rgb.g);
      const B = srgbToLinear(rgb.b);
      return 0.2126 * R + 0.7152 * G + 0.0722 * B;
    }

    function contrastRatio(hex1, hex2) {
      const a = hexToRgb(hex1);
      const b = hexToRgb(hex2);
      if (!a || !b) return null;
      const L1 = relativeLuminance(a);
      const L2 = relativeLuminance(b);
      const lighter = Math.max(L1, L2);
      const darker = Math.min(L1, L2);
      return (lighter + 0.05) / (darker + 0.05);
    }

    // Recommend EC based on printed module size (mm)
    function recommendedECFromModuleMM(moduleMM) {
      if (moduleMM >= 1.0) return "M";
      if (moduleMM >= 0.7) return "Q";
      return "H";
    }

    function cornerRadiusPx() {
      if (frameCornersEl.value === "square") return 0;
      return Number(cornerRadiusEl.value) || 0;
    }

    function setDownloadButtonText() {
      const type = fileTypeEl.value;
      const ext = type === "jpeg" ? "JPG" : type.toUpperCase();
      dlBtn.textContent = `Download ${ext}`;
    }

    function roundedRectPath(ctx, x, y, w, h, r) {
      const rr = Math.max(0, Math.min(r, Math.min(w, h) / 2));
      ctx.beginPath();
      if (rr === 0) {
        ctx.rect(x, y, w, h);
        return;
      }
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

    // --- QR creation + custom render
    let lastCanvas = null;
    let lastMeta = null;

    // Logo state
    let logoImg = null;
    let logoLoaded = false;

    function buildQrMatrix(text, ecKey) {
      const qr = qrcode(0, ecKey); // 'M'|'Q'|'H' (also supports 'L')
      qr.addData(text, "Byte");
      qr.make();
      return qr;
    }

    function renderQrToCanvas(qr, opts) {
      const moduleCount = qr.getModuleCount();
      const quiet = opts.quietModules;
      const totalModules = moduleCount + (quiet * 2);

      // integer pixels-per-module for crisp edges
      const ppm = Math.max(1, Math.floor(opts.targetPx / totalModules));
      const sizePx = totalModules * ppm;

      const canvas = document.createElement("canvas");
      canvas.width = sizePx;
      canvas.height = sizePx;
      const ctx = canvas.getContext("2d");

      // Background/frame
      ctx.clearRect(0, 0, sizePx, sizePx);
      ctx.fillStyle = opts.bgColor;

      const r = Math.min(opts.cornerRadiusPx, Math.floor(sizePx * 0.12));
      roundedRectPath(ctx, 0, 0, sizePx, sizePx, r);
      ctx.fill();

      // Modules
      ctx.fillStyle = opts.fgColor;

      for (let rIdx = 0; rIdx < moduleCount; rIdx++) {
        for (let cIdx = 0; cIdx < moduleCount; cIdx++) {
          if (!qr.isDark(rIdx, cIdx)) continue;
          const x = (cIdx + quiet) * ppm;
          const y = (rIdx + quiet) * ppm;
          ctx.fillRect(x, y, ppm, ppm);
        }
      }

      // Logo overlay (optional)
      if (opts.logoEnabled && opts.logoLoaded && opts.logoImg) {
        const innerPx = moduleCount * ppm; // QR area excluding quiet zone
        const innerX = quiet * ppm;
        const innerY = quiet * ppm;

        const logoPct = Math.max(0.10, Math.min(0.25, opts.logoSizePct)); // clamp
        const logoBox = Math.floor(innerPx * logoPct);
        const pad = Math.max(0, Math.min(50, opts.logoPaddingPx));

        const boxX = innerX + Math.floor((innerPx - logoBox) / 2);
        const boxY = innerY + Math.floor((innerPx - logoBox) / 2);

        // Plate behind logo (helps legibility)
        const plateX = boxX - pad;
        const plateY = boxY - pad;
        const plateW = logoBox + pad * 2;
        const plateH = logoBox + pad * 2;

        ctx.save();
        // Slight rounding on plate
        ctx.fillStyle = opts.logoPlateColor;
        roundedRectPath(ctx, plateX, plateY, plateW, plateH, Math.min(16, Math.floor(plateW * 0.12)));
        ctx.fill();

        // Draw logo
        ctx.drawImage(opts.logoImg, boxX, boxY, logoBox, logoBox);
        ctx.restore();
      }

      return { canvas, ppm, sizePx, totalModules, moduleCount, quiet };
    }

    function canvasToDataUrl(canvas, type, bgColor) {
      if (type === "png") return canvas.toDataURL("image/png");

      // JPEG/WEBP: ensure solid background
      const bg = document.createElement("canvas");
      bg.width = canvas.width;
      bg.height = canvas.height;

      const ctx = bg.getContext("2d");
      ctx.fillStyle = bgColor || "#ffffff";
      ctx.fillRect(0, 0, bg.width, bg.height);
      ctx.drawImage(canvas, 0, 0);

      if (type === "jpeg") return bg.toDataURL("image/jpeg", 0.92);
      if (type === "webp") return bg.toDataURL("image/webp", 0.92);
      return canvas.toDataURL("image/png");
    }

    // Guidance + auto-upgrade EC if needed
    function computeAndApplyGuidance(qrMaybe) {
      const unit = printUnitEl.value;
      const inches = inchesFrom(printSizeEl.value, unit);
      const dpi = Number(dpiEl.value) || 300;
      const quiet = Number(quietZoneEl.value) || 4;

      const fg = fgColorEl.value;
      const bg = bgColorEl.value;
      const cr = contrastRatio(fg, bg);

      let moduleMM = null;
      let recommendedEC = "Q";
      let moduleCount = null;

      if (inches && qrMaybe) {
        moduleCount = qrMaybe.getModuleCount();
        const totalModules = moduleCount + (quiet * 2);
        const moduleInches = inches / totalModules;
        moduleMM = mmFromInches(moduleInches);
        recommendedEC = recommendedECFromModuleMM(moduleMM);
      }

      // If logo enabled, require at least Q (and often H for dense prints)
      if (logoEnabledEl.checked) {
        recommendedEC = maxEC(recommendedEC, "Q");
      }

      // If user chose manual EC, auto-upgrade if below recommended
      const userChoice = ecSelect.value;
      let upgraded = false;
      if (userChoice !== "auto") {
        const effective = maxEC(userChoice, recommendedEC);
        if (effective !== userChoice) {
          ecSelect.value = effective;
          upgraded = true;
        }
      }

      const targetPx = inches ? exportPxFromPrint(inches, dpi) : 512;

      // Compose hint + warnings
      const sizeLabel =
        inches
          ? (unit === "cm" ? `${Number(printSizeEl.value).toFixed(1)} cm` : `${Number(printSizeEl.value).toFixed(1)} in`)
          : "—";

      const pxLine = `<div><strong>Export size:</strong> ~${targetPx}px (based on ${dpi} DPI and ${sizeLabel})</div>`;
      const qzLine = `<div><strong>Quiet zone:</strong> ${quiet} modules</div>`;
      const ecLine = `<div><strong>Recommended EC:</strong> ${recommendedEC}${upgraded ? " (auto-upgraded)" : ""}</div>`;

      const moduleLine =
        moduleMM != null
          ? `<div><strong>Module size:</strong> ~${moduleMM.toFixed(2)} mm per module (bigger is easier to scan)</div>`
          : `<div><strong>Module size:</strong> generate a QR to calculate precisely</div>`;

      const contrastLine =
        cr != null
          ? `<div><strong>Contrast ratio:</strong> ${cr.toFixed(2)}:1</div>`
          : `<div><strong>Contrast ratio:</strong> —</div>`;

      // Contrast warning thresholds:
      // - < 3:1 is risky
      // - 3–7:1 is okay-ish but not ideal for print/scanning in varied lighting
      // - >= 7:1 is strong
      let contrastWarn = "";
      hintEl.classList.remove("warn", "bad");

      if (cr != null) {
        if (cr < 3.0) {
          hintEl.classList.add("bad");
          contrastWarn = `<div style="margin-top:6px;"><strong>Warning:</strong> Very low contrast. Choose a darker foreground and lighter background.</div>`;
        } else if (cr < 7.0) {
          hintEl.classList.add("warn");
          contrastWarn = `<div style="margin-top:6px;"><strong>Heads up:</strong> Contrast is moderate. For best scanning (especially print), aim for 7:1 or higher.</div>`;
        }
      }

      // Density warning
      let densityWarn = "";
      if (moduleMM != null && moduleMM < 0.6) {
        hintEl.classList.add("warn");
        densityWarn = `<div style="margin-top:6px;"><strong>Warning:</strong> This is dense for that print size. Consider larger print width, higher quiet zone, or shorter URL.</div>`;
      }

      // Logo note
      const logoNote = logoEnabledEl.checked
        ? `<div style="margin-top:6px;"><strong>Logo:</strong> enabled (we recommend EC ≥ Q; H if printing small).</div>`
        : "";

      hintEl.innerHTML =
        `<div><strong>Print + robustness guidance</strong></div>` +
        moduleLine + ecLine + pxLine + qzLine + contrastLine + logoNote + contrastWarn + densityWarn;

      return { inches, dpi, quiet, recommendedEC, targetPx, moduleMM, contrast: cr };
    }

    function effectiveECForGenerate(recommendedEC) {
      const userChoice = ecSelect.value;
      if (userChoice === "auto") return recommendedEC;
      return userChoice; // may already have been upgraded
    }

    function refreshCornerUI() {
      const isRounded = frameCornersEl.value === "rounded";
      cornerRadiusEl.disabled = !isRounded;
      cornerRadiusNote.style.opacity = isRounded ? "1" : "0.6";
      cornerRadiusNote.textContent = `${cornerRadiusPx()} px`;
    }

    function refreshLogoUI() {
      const enabled = logoEnabledEl.checked;
      logoSizeEl.disabled = !enabled;
      logoPaddingEl.disabled = !enabled;
      logoPlateEl.disabled = !enabled;
      logoSizeNote.style.opacity = enabled ? "1" : "0.6";
      logoPaddingNote.style.opacity = enabled ? "1" : "0.6";
      logoPreviewRow.style.display = (enabled && logoLoaded) ? "flex" : "none";
      logoSizeNote.textContent = `${logoSizeEl.value}%`;
      logoPaddingNote.textContent = `${logoPaddingEl.value} px`;
    }

    function generate() {
      const text = normalizeValue(input.value);

      qrBox.innerHTML = "";
      dlBtn.disabled = true;
      lastCanvas = null;
      lastMeta = null;

      // Update slider notes
      cornerRadiusNote.textContent = `${cornerRadiusPx()} px`;
      logoSizeNote.textContent = `${logoSizeEl.value}%`;
      logoPaddingNote.textContent = `${logoPaddingEl.value} px`;

      if (!text) {
        computeAndApplyGuidance(null);
        return;
      }

      const quiet = Number(quietZoneEl.value) || 4;

      // Build a provisional matrix for accurate module sizing
      let qr = buildQrMatrix(text, "Q");
      const guidance = computeAndApplyGuidance(qr);

      // Choose EC (auto uses guidance; manual may have been upgraded)
      const ecKey = effectiveECForGenerate(guidance.recommendedEC);

      if (ecKey !== "Q") {
        qr = buildQrMatrix(text, ecKey);
        // Recompute guidance for actual EC (module count can change)
        Object.assign(guidance, computeAndApplyGuidance(qr));
      }

      const opts = {
        targetPx: guidance.targetPx,
        quietModules: quiet,
        cornerRadiusPx: cornerRadiusPx(),
        fgColor: fgColorEl.value,
        bgColor: bgColorEl.value,

        logoEnabled: logoEnabledEl.checked,
        logoLoaded,
        logoImg,
        logoSizePct: (Number(logoSizeEl.value) || 16) / 100,
        logoPaddingPx: Number(logoPaddingEl.value) || 0,
        logoPlateColor: logoPlateEl.value
      };

      const render = renderQrToCanvas(qr, opts);
      qrBox.appendChild(render.canvas);

      lastCanvas = render.canvas;
      lastMeta = {
        ec: ecKey,
        printInches: guidance.inches,
        dpi: guidance.dpi,
        exportPx: render.sizePx
      };

      dlBtn.disabled = false;
      setDownloadButtonText();
    }

    function downloadQr() {
      if (!lastCanvas) return;

      const type = fileTypeEl.value;
      const bg = bgColorEl.value;
      const dataUrl = canvasToDataUrl(lastCanvas, type, bg);
      const ext = type === "jpeg" ? "jpg" : type;

      let suffix = "";
      if (lastMeta?.printInches && lastMeta?.dpi) {
        const inches = lastMeta.printInches;
        const approx = inches >= 1 ? `${inches.toFixed(2)}in` : `${(inches*25.4).toFixed(0)}mm`;
        suffix = `_${approx}_${lastMeta.dpi}dpi_EC-${lastMeta.ec}`;
      }

      const a = document.createElement("a");
      a.href = dataUrl;
      a.download = `qr${suffix}.${ext}`;
      a.click();
    }

    function onPrintRelatedChange() {
      if (lastCanvas) generate();
      else computeAndApplyGuidance(null);
    }

    // --- Logo upload
    function handleLogoFile(file) {
      logoLoaded = false;
      logoImg = null;

      if (!file) {
        logoPreviewRow.style.display = "none";
        return;
      }

      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          logoImg = img;
          logoLoaded = true;

          logoPreviewImg.src = img.src;
          logoPreviewRow.style.display = (logoEnabledEl.checked ? "flex" : "none");
          logoInfoEl.textContent = `${file.name} • ${img.naturalWidth}×${img.naturalHeight}`;

          // If a QR exists, regenerate to apply the logo
          if (lastCanvas) generate();
          else computeAndApplyGuidance(null);
        };
        img.src = reader.result;
      };
      reader.readAsDataURL(file);
    }

    // --- Events
    genBtn.addEventListener("click", generate);
    dlBtn.addEventListener("click", downloadQr);

    input.addEventListener("keydown", (e) => { if (e.key === "Enter") generate(); });
    input.addEventListener("input", () => { if (!lastCanvas) computeAndApplyGuidance(null); });

    printSizeEl.addEventListener("input", onPrintRelatedChange);
    printUnitEl.addEventListener("change", onPrintRelatedChange);
    dpiEl.addEventListener("change", onPrintRelatedChange);
    quietZoneEl.addEventListener("change", onPrintRelatedChange);

    ecSelect.addEventListener("change", () => {
      if (lastCanvas) generate();
      else computeAndApplyGuidance(null);
    });

    frameCornersEl.addEventListener("change", () => {
      refreshCornerUI();
      if (lastCanvas) generate();
    });

    cornerRadiusEl.addEventListener("input", () => {
      cornerRadiusNote.textContent = `${cornerRadiusPx()} px`;
      if (lastCanvas) generate();
    });

    fileTypeEl.addEventListener("change", setDownloadButtonText);

    fgColorEl.addEventListener("input", () => {
      if (lastCanvas) generate();
      else computeAndApplyGuidance(null);
    });
    bgColorEl.addEventListener("input", () => {
      if (lastCanvas) generate();
      else computeAndApplyGuidance(null);
    });

    logoEnabledEl.addEventListener("change", () => {
      refreshLogoUI();
      // Turning on logo increases recommended EC; apply guidance immediately
      if (lastCanvas) generate();
      else computeAndApplyGuidance(null);
    });

    logoFileEl.addEventListener("change", (e) => {
      const f = e.target.files && e.target.files[0];
      handleLogoFile(f || null);
    });

    logoSizeEl.addEventListener("input", () => {
      logoSizeNote.textContent = `${logoSizeEl.value}%`;
      if (lastCanvas) generate();
    });

    logoPaddingEl.addEventListener("input", () => {
      logoPaddingNote.textContent = `${logoPaddingEl.value} px`;
      if (lastCanvas) generate();
    });

    logoPlateEl.addEventListener("input", () => {
      if (lastCanvas) generate();
    });

    // --- Init
    refreshCornerUI();
    refreshLogoUI();
    setDownloadButtonText();
    computeAndApplyGuidance(null);
  </script>
</body>
</html>
